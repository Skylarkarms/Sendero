package sendero;

import sendero.atomics.AtomicUtils;
import sendero.pairs.Pair;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;

public class PathListeners {
    public static abstract class AbsListener<T> implements PathListener<T> {
        private final AtomicUtils.TaggedAtomicReference<BasePath<?>, Appointer<?>> basePathAtomicReference = new AtomicUtils.TaggedAtomicReference<>();
//        static class Appointer<A> {
//            final BasePath<A> producer;
//            final Consumer<Pair.Immutables.Int<A>> toAppoint;
//
//            Appointer(BasePath<A> producer, Consumer<Pair.Immutables.Int<A>> toAppoint) {
//                this.producer = producer;
//                this.toAppoint = toAppoint;
//            }
//            void appoint() {
//                producer.appoint(toAppoint);
//            }
//            void demote() {
//                if (producer instanceof BasePath.ToMany) {
//                    ((BasePath.ToMany<A>) producer).demote(toAppoint);
//                } else {
//                    assert producer instanceof BasePath.Injective;
//                    ((BasePath.Injective<A>) producer).demote();
//                }
//            }
//        }
        abstract void onResult(Pair.Immutables.Int<T> result);
        abstract void onSwapped();

        @Override
        public <S, P extends BasePath<S>> void listen(P basePath, Function<S, T> map) {
            final Consumer<Pair.Immutables.Int<S>> intConsumer = anInt -> onResult(new Pair.Immutables.Int<>(anInt.getInt(), map.apply((S) anInt.getValue())));
            final Appointer<?> next = new Appointer<>(basePath, intConsumer);
            final Appointer<?> prev = basePathAtomicReference.getAndDiffUpdate(basePath, next);
            if (next != prev) {
                boolean prevNotNull = prev != null;
                if (prevNotNull) prev.demote();
                //contention check
                if (basePathAtomicReference.contains(basePath)) {
                    if (prevNotNull) onSwapped();
                    next.appoint();
                }
            }
        }

        @Override
        public <P extends BasePath<T>> void setAndStart(P basePath) {
            listen(basePath, UnaryOperator.identity());
        }

        @Override
        public void stopAndClearPath() {
            Appointer<?> appointer = basePathAtomicReference.getAndClear();
            if (appointer != null) {
                appointer.demote();
                //contention check
//                if (basePathAtomicReference.isCleared()) self.invalidate();
            }
        }
    }

//    public static abstract class Holder<T> extends Holders.DispatcherHolder<T> implements PathListener<T> {
//
//        public Holder(AtomicReference<Pair.Immutables.Int<T>> reference, UnaryOperator<T> map, Predicate<T> expectInput) {
//            super(reference, map, expectInput);
//        }
//
//        private final AbsListener<T> listener = new AbsListener<T>() {
//            @Override
//            void onResult(Pair.Immutables.Int<T> result) {
//                acceptVersionValue(result);
//            }
//
//            @Override
//            void onSwapped() {
//                invalidate();
//            }
//        };
//
//        @Override
//        public <S, P extends BasePath<S>> void listen(P basePath, Function<S, T> map) {
//            listener.listen(basePath, map);
//        }
//
//        @Override
//        public <P extends BasePath<T>> void listen(P basePath) {
//            listener.listen(basePath);
//        }
//
//        @Override
//        public void stopAndClearPath() {
//            listener.stopAndClearPath();
//        }
//
//        abstract void onResult(Pair.Immutables.Int<T> result);
//
//        @Override
//        protected void coldDispatch(Pair.Immutables.Int<T> t) {
//            onResult(t);
//        }
//    }
}
